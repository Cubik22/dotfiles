#!/bin/bash

# functionrc
# functions for bash and zsh

# source phel
phelrc="$HOME/.config/shell/phelrc"
[ -f "$phelrc" ] && source "$phelrc"

# wrapper around kak
# cd if directory
# open with kak if file
# supposed to be used just with aliases
kak-smart () {
	# first parameter check if running as root
	if [ "$#" -le 0 ]; then
	    echo "please insert the first parameter: whether or no to run as root"
	    return 1
	fi

	root="$1"

	if [ "$root" != "yes" ] && [ "$root" != "no" ]; then
    	echo "the first parameter determine if running as root or not"
    	echo "values accepted are yes or no"
    	return 1
    fi

	shift 1

	if [ "$#" -le 0 ]; then
	    echo "please insert a parameter: directory or file"
	    return 1
	fi

	arg="$1"

	if [ -d "$arg" ]; then
	    cd "$arg" || return 1
	elif [ -f "$arg" ]; then
		if [ "$root" = "no" ]; then
	    	/bin/kak "$arg"
	    elif [ "$root" = "yes" ]; then
    	    doas /bin/kak "$arg"
		fi
	else
	    # if is not an existing directory or file
	    # if nevertheless exists then do not open it
	    # if it does not exists then can be opened as a file by kak
	    if [ -e "$arg" ]; then
	        echo "the argument exists but is neither a directory or file"
	        /bin/ls --color=auto --human-readable -l "$arg"
    	    /bin/file "$arg"
	    else
			if [ "$root" = "no" ]; then
	    		/bin/kak "$arg"
	    	elif [ "$root" = "yes" ]; then
    		    doas /bin/kak "$arg"
			fi
	    fi
	fi
}

# spawn zathura in a specified river tag
# better spa (global script)
zat () {
	if [ "$#" -lt 2 ]; then
    	echo "insert at least two parameters"
    	echo "first parameter: tag"
    	echo "other parameters: arguments"
    	return 1
	fi
    tag="$1"
	# shift arguments by two, now 3 becomes 0
	shift 1
    riverctl set-focused-tags "$((1 << ("$tag" - 1)))"
    riverctl spawn "zathura $*"
}

# wrapper around git that before push, unlock bitwarden
git () {
	if [ "$#" -ge 1 ] && [ "$1" = "push" ]; then
		rbw unlock
	fi
	/usr/bin/git "$@"
}

# git bare repository user dotfiles
ucon () {
	# when adding echo to remember to pull before commit
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "add" ]; then
			echo "remember to pull before commit"
		elif [ "$1" = "push" ]; then
			rbw unlock
		fi
	fi
	local work_tree="$HOME"
	local git_dir="$HOME/.dotfiles"
	/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" "$@"
	# when pulling remove README from work_tree and set git to not track in locale
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "pull" ]; then
			/usr/bin/rm -f "$work_tree"/README.md
			/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" update-index --assume-unchanged "$work_tree"/README.md
		fi
	fi
}

# git bare repository root config files
rcon () {
	# make sure that when running as user use doas
	if [ "$LOGNAME" = "root" ] || [ "$(id -u)" -eq 0 ]; then
		local as_root="true"
	else
		local as_root="false"
	fi
	# when adding echo to remember to pull before commit
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "add" ]; then
			echo "remember to pull before commit"
		elif [ "$1" = "push" ]; then
			if [ "$as_root" = "true" ]; then
				rbw unlock
			else
				doas rbw unlock
			fi
		fi
	fi
	local work_tree="/"
	local git_dir="/root/config"
	if [ "$as_root" = "true" ]; then
		/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" "$@"
	else
		doas /usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" "$@"
	fi
	# when pulling remove README from work_tree and set git to not track in locale
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "pull" ]; then
			if [ "$as_root" = "true" ]; then
				/usr/bin/rm -f "$work_tree"/README.md
				/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" update-index --assume-unchanged "$work_tree"/README.md
			else
				doas /usr/bin/rm -f "$work_tree"/README.md
				doas /usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" update-index --assume-unchanged "$work_tree"/README.md
			fi
		fi
	fi
}

# create a file and automatically add it with ucon
utouch () {
	if [ "$#" -le 0 ]; then
    	echo "at least one parameter: the name of the file to be created"
    	return 1
	elif [ "$#" -gt 2 ]; then
    	echo "too many arguments"
    	echo "first parameter file second optional to pass to chmod"
    	return 1
	fi
    file="$1"
    touch "$file"
	if [ "$#" -eq 2 ]; then
        chmod "$2" "$file"
	fi
	ucon add "$file"
}

# create a file and automatically add it with rcon
rtouch () {
	if [ "$#" -le 0 ]; then
    	echo "at least one parameter: the name of the file to be created"
    	return 1
	elif [ "$#" -gt 2 ]; then
    	echo "too many arguments"
    	echo "first parameter file second optional to pass to chmod"
    	return 1
	fi
    file="$1"
    doas touch "$file"
	if [ "$#" -eq 2 ]; then
        doas chmod "$2" "$file"
	fi
	rcon add "$file"
}

# old
# audocd when pressing ^G
# nnn () {
#     # Block nesting of nnn in subshells
#     if [ -n "$NNNLVL" ] && [ "${NNNLVL:-0}" -ge 1 ]; then
#         echo "nnn is already running"
#         return 1
#     fi

#     # The behaviour is set to cd on quit (nnn checks if NNN_TMPFILE is set)
#     # To cd on quit only on ^G, either remove the "export" as in:
#     # NNN_TMPFILE="$XDG_STATE_HOME"/nnn/lastd
#     # (or, to a custom path: NNN_TMPFILE=/tmp/lastd)
#     # or, export NNN_TMPFILE after nnn invocation
#     export NNN_TMPFILE="$XDG_STATE_HOME"/nnn/lastd

#     # Unmask ^Q (, ^V etc.) (if required, see `stty -a`) to Quit nnn
#     # stty start undef
#     # stty stop undef
#     # stty lwrap undef
#     # stty lnext undef

#     /bin/nnn "$@"

#     # uncomment to cd on quit only on ^G
#     # NNN_TMPFILE="$XDG_STATE_HOME"/nnn/lastd

#     if [ -f "$NNN_TMPFILE" ]; then
#     	. "$NNN_TMPFILE"
#     	rm -f "$NNN_TMPFILE"
#     fi
# }

# audocd when pressing ^G
# edit also nnn-pre
nnn () {
    # block nesting of nnn in subshells
    if [ -n "$NNNLVL" ] && [ "${NNNLVL:-0}" -ge 1 ]; then
        echo "nnn is already running"
        return 1
    fi

    NNN_TMPFILE="$XDG_CONFIG_HOME"/nnn/.lastd

    # make sure tmp file does not exists before starting nnn
    rm -f "$NNN_TMPFILE"

    /bin/nnn "$@"

    # source tmp file which is created just when <C-g> is pressed
    [ -f "$NNN_TMPFILE" ] && . "$NNN_TMPFILE"

    rm -f "$NNN_TMPFILE"
}

# start nnn with preview
# https://github.com/jarun/nnn/wiki/Live-previews
nnn-pre () {
    # block nesting of nnn in subshells
    if [ -n "$NNNLVL" ] && [ "${NNNLVL:-0}" -ge 1 ]; then
        echo "nnn is already running"
        return 1
    fi

    NNN_TMPFILE="$XDG_CONFIG_HOME"/nnn/.lastd

    # this will create a fifo where all nnn selections will be written to
    # NNN_FIFO="$(mktemp --suffix=-nnn -u)"
    # export NNN_FIFO

    rm -f "$NNN_FIFO"
    (umask 077; mkfifo "$NNN_FIFO")

    # preview command
    preview_cmd="$XDG_CONFIG_HOME/nnn/plugins/preview-cmd"

    # use a new window with foot as a preview window
    if (which riverctl &> /dev/null) && (which footclient &> /dev/null); then
        riverctl spawn "footclient $preview_cmd"
        # wait some time otherwise river is still focused on the previous tag
        sleep 0.01
        riverctl focus-view previous
    else
        echo "unable to open preview, please install river and foot"
    fi

    # make sure tmp file does not exists before starting nnn
    rm -f "$NNN_TMPFILE"

    /bin/nnn "$@"

    # source tmp file which is created just when <C-g> is pressed
    [ -f "$NNN_TMPFILE" ] && . "$NNN_TMPFILE"

    rm -f "$NNN_TMPFILE"

    rm -f "$NNN_FIFO"
}
