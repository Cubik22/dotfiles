#!/bin/bash

# functionrc
# functions for bash and zsh

# source phel
phelrc="$HOME/.config/shell/phelrc"
[ -f "$phelrc" ] && . "$phelrc"

# touch file and change its permissions
touch-per() {
    if [ "$#" -ne 2 ]; then
        echo "error: insert two parameters"
        echo "first: name of file"
        echo "second: permissions to pass to chmod"
        return 1
    fi
    permissions="$1"
    file="$2"
    touch "$file"
    chmod "$permissions" "$file"
}

# use dark theme for zathura
# change also zat and spa
zathura() {
	export GTK_THEME=Adwaita:dark
	/bin/zathura "$@"
}

# wrapper around kak
# cd if directory
# open with kak if file
# supposed to be used just with aliases
kak-smart() {
    # first parameter check if running as root
    if [ "$#" -le 0 ]; then
        echo "please insert the first parameter: whether or no to run as root"
        return 1
    fi

    root="$1"

    if [ "$root" != "yes" ] && [ "$root" != "no" ]; then
    	echo "the first parameter determine if running as root or not"
    	echo "values accepted are yes or no"
    	return 1
    fi

    shift 1

    if [ "$#" -gt 0 ]; then
        arg="$1"

        if [ -d "$arg" ]; then
            cd "$arg" || return 1
        elif [ -f "$arg" ]; then
        	if [ "$root" = "no" ]; then
            	/bin/kak "$arg"
            elif [ "$root" = "yes" ]; then
        	    doas /bin/kak "$arg"
        	fi
        else
            # if is not an existing directory or file
            # if nevertheless exists then do not open it
            # if it does not exists then can be opened as a file by kak
            if [ -e "$arg" ]; then
                echo "the argument exists but is neither a directory or file"
                /bin/ls --color=auto --human-readable -l "$arg"
        	    /bin/file "$arg"
            else
        		if [ "$root" = "no" ]; then
            		/bin/kak "$arg"
            	elif [ "$root" = "yes" ]; then
        		    doas /bin/kak "$arg"
        		fi
            fi
        fi
    else
        # run fzf for files with preview
        file="$($FZF_DEFAULT_COMMAND --type file | fzf --preview="$FZF_DEFAULT_PREVIEW")"
        # clear last command (kak)
        # below it is substituted by the real command (kak file)
        history -d -1
        if [ -e "$file" ]; then
        	if [ "$root" = "no" ]; then
        		/bin/kak "$file"
            	history -ps "kak $file"
        	elif [ "$root" = "yes" ]; then
        	    doas /bin/kak "$file"
            	history -ps "doas kak $file"
        	fi
        fi
    fi
}

# wrapper around git that before push, unlock bitwarden
git() {
	if [ "$#" -ge 1 ] && [ "$1" = "push" ]; then
		rbw unlock
	fi
	/usr/bin/git "$@"
}

# git bare repository user dotfiles
ucon() {
	# when adding echo to remember to pull before commit
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "add" ]; then
			echo "remember to pull before commit"
		elif [ "$1" = "push" ]; then
			rbw unlock
		fi
	fi
	local work_tree="$HOME"
	local git_dir="$HOME/.dotfiles"
	/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" "$@"
	# when pulling remove README from work_tree and set git to not track in locale
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "pull" ]; then
			/usr/bin/rm -f "$work_tree"/README.md
			/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" update-index --assume-unchanged "$work_tree"/README.md
		fi
	fi
} && export -f ucon

# git bare repository root config files
rcon() {
	# make sure that when running as user use doas
	if [ "$LOGNAME" = "root" ] || [ "$(id -u)" -eq 0 ]; then
		local as_root="true"
	else
		local as_root="false"
	fi
	# when adding echo to remember to pull before commit
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "add" ]; then
			echo "remember to pull before commit"
		elif [ "$1" = "push" ]; then
			if [ "$as_root" = "true" ]; then
				rbw unlock
			else
				doas rbw unlock
			fi
		fi
	fi
	local work_tree="/"
	local git_dir="/root/config"
	if [ "$as_root" = "true" ]; then
		/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" "$@"
	else
		doas /usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" "$@"
	fi
	# when pulling remove README from work_tree and set git to not track in locale
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "pull" ]; then
			if [ "$as_root" = "true" ]; then
				/usr/bin/rm -f "$work_tree"/README.md
				/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" update-index --assume-unchanged "$work_tree"/README.md
			else
				doas /usr/bin/rm -f "$work_tree"/README.md
				doas /usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" update-index --assume-unchanged "$work_tree"/README.md
			fi
		fi
	fi
} && export -f rcon

# create a file and automatically add it with ucon
utouch() {
	if [ "$#" -le 0 ]; then
    	echo "at least one parameter: the name of the file to be created"
    	return 1
	elif [ "$#" -gt 2 ]; then
    	echo "too many arguments"
    	echo "first parameter file second optional to pass to chmod"
    	return 1
	fi
    file="$1"
    touch "$file"
	if [ "$#" -eq 2 ]; then
        chmod "$2" "$file"
	fi
	ucon add "$file"
} && export -f utouch

# create a file and automatically add it with rcon
rtouch() {
	if [ "$#" -le 0 ]; then
    	echo "at least one parameter: the name of the file to be created"
    	return 1
	elif [ "$#" -gt 2 ]; then
    	echo "too many arguments"
    	echo "first parameter file second optional to pass to chmod"
    	return 1
	fi
    file="$1"
    doas touch "$file"
	if [ "$#" -eq 2 ]; then
        doas chmod "$2" "$file"
	fi
	rcon add "$file"
} && export -f rtouch

# old
# audocd when pressing ^G
# nnn() {
#     # Block nesting of nnn in subshells
#     if [ -n "$NNNLVL" ] && [ "${NNNLVL:-0}" -ge 1 ]; then
#         echo "nnn is already running"
#         return 1
#     fi

#     # The behaviour is set to cd on quit (nnn checks if NNN_TMPFILE is set)
#     # To cd on quit only on ^G, either remove the "export" as in:
#     # NNN_TMPFILE="$XDG_STATE_HOME"/nnn/lastd
#     # (or, to a custom path: NNN_TMPFILE=/tmp/lastd)
#     # or, export NNN_TMPFILE after nnn invocation
#     export NNN_TMPFILE="$XDG_STATE_HOME"/nnn/lastd

#     # Unmask ^Q (, ^V etc.) (if required, see `stty -a`) to Quit nnn
#     # stty start undef
#     # stty stop undef
#     # stty lwrap undef
#     # stty lnext undef

#     /bin/nnn "$@"

#     # uncomment to cd on quit only on ^G
#     # NNN_TMPFILE="$XDG_STATE_HOME"/nnn/lastd

#     if [ -f "$NNN_TMPFILE" ]; then
#     	. "$NNN_TMPFILE"
#     	rm -f "$NNN_TMPFILE"
#     fi
# }

# audocd when pressing ^G
# edit also nnn-pre
nnn() {
    # block nesting of nnn in subshells
    if [ -n "$NNNLVL" ] && [ "${NNNLVL:-0}" -ge 1 ]; then
        echo "nnn is already running"
        return 1
    fi

    NNN_TMPFILE="$XDG_CONFIG_HOME"/nnn/.lastd

    # make sure tmp file does not exists before starting nnn
    rm -f "$NNN_TMPFILE"

    /bin/nnn "$@"

    # source tmp file which is created just when <C-g> is pressed
    [ -f "$NNN_TMPFILE" ] && . "$NNN_TMPFILE"

    rm -f "$NNN_TMPFILE"
}

# start nnn with preview
# https://github.com/jarun/nnn/wiki/Live-previews
nnn-pre() {
    # block nesting of nnn in subshells
    if [ -n "$NNNLVL" ] && [ "${NNNLVL:-0}" -ge 1 ]; then
        echo "nnn is already running"
        return 1
    fi

    NNN_TMPFILE="$XDG_CONFIG_HOME"/nnn/.lastd

    # this will create a fifo where all nnn selections will be written to
    # NNN_FIFO="$(mktemp --suffix=-nnn -u)"
    # export NNN_FIFO

    rm -f "$NNN_FIFO"
    (umask 077; mkfifo "$NNN_FIFO")

    # preview command
    preview_cmd="$XDG_CONFIG_HOME/nnn/plugins/preview-cmd"

    exists() {
        command -v "$1" >/dev/null 2>&1
    }

    # use a new window with foot as a preview window
    if exists riverctl && exists footclient; then
        riverctl spawn "footclient $preview_cmd"
        # wait some time otherwise river is still focused on the previous tag
        sleep 0.01
        riverctl focus-view previous
    else
        echo "unable to open preview, please install river and foot"
    fi

    # make sure tmp file does not exists before starting nnn
    rm -f "$NNN_TMPFILE"

    /bin/nnn "$@"

    # source tmp file which is created just when <C-g> is pressed
    [ -f "$NNN_TMPFILE" ] && . "$NNN_TMPFILE"

    rm -f "$NNN_TMPFILE"

    rm -f "$NNN_FIFO"
}
