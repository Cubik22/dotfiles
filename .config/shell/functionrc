#!/bin/bash

# functionrc
# functions for bash and zsh

# source phel
phelrc="$HOME/.config/shell/phelrc"
[ -f "$phelrc" ] && . "$phelrc"

# use dark theme for zathura
# change also zat and spa
zathura() {
	export GTK_THEME=Adwaita:dark
	/bin/zathura "$@"
}

# spawn zathura in a specified river tag
# better spa (global script)
zat() {
	if [ "$#" -lt 1 ]; then
    	echo "insert at least one parameter"
    	echo "first parameter: tag (optional)"
    	echo "if no tag is specified zathura is spawn in the current focused tag"
    	echo "other parameters: arguments for zathura"
    	return 1
    fi
    # check that the first parameter is a number
    if [ "$#" -gt 1 ] && [ "$1" -ge 0 ] 2> /dev/null; then
        tag="$1"
    	# shift arguments by one, now 2 becomes 1
    	shift 1
        riverctl set-focused-tags "$((1 << ("$tag" - 1)))"
    fi
    # append pwd to the file (last parameter)
    current_dir="$(pwd)"
    i=0
    while [ $((i+=1)) -lt "$#" ]; do
        set -- "$@" "$1"
        shift
    done
    file="$1"
    shift
    riverctl spawn "export GTK_THEME=Adwaita:dark; /bin/zathura $* $current_dir/$file"
}

# wrapper around git that before push, unlock bitwarden
git() {
	if [ "$#" -ge 1 ] && [ "$1" = "push" ]; then
		rbw unlock
	fi
	/usr/bin/git "$@"
}

# git bare repository user dotfiles
ucon() {
	# when adding echo to remember to pull before commit
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "add" ]; then
			echo "remember to pull before commit"
		elif [ "$1" = "push" ]; then
			rbw unlock
		fi
	fi
	local work_tree="$HOME"
	local git_dir="$HOME/.dotfiles"
	/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" "$@"
	# when pulling remove README from work_tree and set git to not track in locale
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "pull" ]; then
			/usr/bin/rm -f "$work_tree"/README.md
			/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" update-index --assume-unchanged "$work_tree"/README.md
		fi
	fi
} && export -f ucon

# git bare repository root config files
rcon() {
	# make sure that when running as user use doas
	if [ "$LOGNAME" = "root" ] || [ "$(id -u)" -eq 0 ]; then
		local as_root="true"
	else
		local as_root="false"
	fi
	# when adding echo to remember to pull before commit
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "add" ]; then
			echo "remember to pull before commit"
		elif [ "$1" = "push" ]; then
			if [ "$as_root" = "true" ]; then
				rbw unlock
			else
				doas rbw unlock
			fi
		fi
	fi
	local work_tree="/"
	local git_dir="/root/config"
	if [ "$as_root" = "true" ]; then
		/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" "$@"
	else
		doas /usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" "$@"
	fi
	# when pulling remove README from work_tree and set git to not track in locale
	if [ "$#" -ge 1 ]; then
		if [ "$1" = "pull" ]; then
			if [ "$as_root" = "true" ]; then
				/usr/bin/rm -f "$work_tree"/README.md
				/usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" update-index --assume-unchanged "$work_tree"/README.md
			else
				doas /usr/bin/rm -f "$work_tree"/README.md
				doas /usr/bin/git --git-dir="$git_dir"/ --work-tree="$work_tree" update-index --assume-unchanged "$work_tree"/README.md
			fi
		fi
	fi
} && export -f rcon

# create a file and automatically add it with ucon
utouch() {
	if [ "$#" -le 0 ]; then
    	echo "at least one parameter: the name of the file to be created"
    	return 1
	elif [ "$#" -gt 2 ]; then
    	echo "too many arguments"
    	echo "first parameter file second optional to pass to chmod"
    	return 1
	fi
    file="$1"
    touch "$file"
	if [ "$#" -eq 2 ]; then
        chmod "$2" "$file"
	fi
	ucon add "$file"
} && export -f utouch

# create a file and automatically add it with rcon
rtouch() {
	if [ "$#" -le 0 ]; then
    	echo "at least one parameter: the name of the file to be created"
    	return 1
	elif [ "$#" -gt 2 ]; then
    	echo "too many arguments"
    	echo "first parameter file second optional to pass to chmod"
    	return 1
	fi
    file="$1"
    doas touch "$file"
	if [ "$#" -eq 2 ]; then
        doas chmod "$2" "$file"
	fi
	rcon add "$file"
} && export -f rtouch

# old
# audocd when pressing ^G
# nnn() {
#     # Block nesting of nnn in subshells
#     if [ -n "$NNNLVL" ] && [ "${NNNLVL:-0}" -ge 1 ]; then
#         echo "nnn is already running"
#         return 1
#     fi

#     # The behaviour is set to cd on quit (nnn checks if NNN_TMPFILE is set)
#     # To cd on quit only on ^G, either remove the "export" as in:
#     # NNN_TMPFILE="$XDG_STATE_HOME"/nnn/lastd
#     # (or, to a custom path: NNN_TMPFILE=/tmp/lastd)
#     # or, export NNN_TMPFILE after nnn invocation
#     export NNN_TMPFILE="$XDG_STATE_HOME"/nnn/lastd

#     # Unmask ^Q (, ^V etc.) (if required, see `stty -a`) to Quit nnn
#     # stty start undef
#     # stty stop undef
#     # stty lwrap undef
#     # stty lnext undef

#     /bin/nnn "$@"

#     # uncomment to cd on quit only on ^G
#     # NNN_TMPFILE="$XDG_STATE_HOME"/nnn/lastd

#     if [ -f "$NNN_TMPFILE" ]; then
#     	. "$NNN_TMPFILE"
#     	rm -f "$NNN_TMPFILE"
#     fi
# }

# audocd when pressing ^G
# edit also nnn-pre
nnn() {
    # block nesting of nnn in subshells
    if [ -n "$NNNLVL" ] && [ "${NNNLVL:-0}" -ge 1 ]; then
        echo "nnn is already running"
        return 1
    fi

    NNN_TMPFILE="$XDG_CONFIG_HOME"/nnn/.lastd

    # make sure tmp file does not exists before starting nnn
    rm -f "$NNN_TMPFILE"

    /bin/nnn "$@"

    # source tmp file which is created just when <C-g> is pressed
    [ -f "$NNN_TMPFILE" ] && . "$NNN_TMPFILE"

    rm -f "$NNN_TMPFILE"
}

# start nnn with preview
# https://github.com/jarun/nnn/wiki/Live-previews
nnn-pre() {
    # block nesting of nnn in subshells
    if [ -n "$NNNLVL" ] && [ "${NNNLVL:-0}" -ge 1 ]; then
        echo "nnn is already running"
        return 1
    fi

    NNN_TMPFILE="$XDG_CONFIG_HOME"/nnn/.lastd

    # this will create a fifo where all nnn selections will be written to
    # NNN_FIFO="$(mktemp --suffix=-nnn -u)"
    # export NNN_FIFO

    rm -f "$NNN_FIFO"
    (umask 077; mkfifo "$NNN_FIFO")

    # preview command
    preview_cmd="$XDG_CONFIG_HOME/nnn/plugins/preview-cmd"

    exists() {
        command -v "$1" >/dev/null 2>&1
    }

    # use a new window with foot as a preview window
    if exists riverctl && exists footclient; then
        riverctl spawn "footclient $preview_cmd"
        # wait some time otherwise river is still focused on the previous tag
        sleep 0.01
        riverctl focus-view previous
    else
        echo "unable to open preview, please install river and foot"
    fi

    # make sure tmp file does not exists before starting nnn
    rm -f "$NNN_TMPFILE"

    /bin/nnn "$@"

    # source tmp file which is created just when <C-g> is pressed
    [ -f "$NNN_TMPFILE" ] && . "$NNN_TMPFILE"

    rm -f "$NNN_TMPFILE"

    rm -f "$NNN_FIFO"
}
