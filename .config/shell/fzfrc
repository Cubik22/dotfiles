#!/bin/bash

# fzfrc

possible_base_dir="/usr/share/fzf /usr/local/share/fzf/bash"
completion_file="completion.bash"
key_bindings_file="key-bindings.bash"
for base_dir in $possible_base_dir; do
    if [ -d "$base_dir" ]; then
        # shellcheck disable=SC1090
        [ -f "$base_dir/$completion_file" ] && . "$base_dir/$completion_file"
        # shellcheck disable=SC1090
        [ -f "$base_dir/$key_bindings_file" ] && . "$base_dir/$key_bindings_file"
        break
    fi
done
unset possible_base_dir
unset base_dir
unset completion_file
unset key_bindings_file

# use fd (https://github.com/sharkdp/fd) instead of the default find
# command for listing path candidates.
# - the first argument to the function ($1) is the base path to start traversal
# - see the source code (/usr/share/fzf/completion.bash) for the details.
# FZF_DEFAULT_COMMAND defined in .config/shell/envrc
_fzf_compgen_path() {
    $FZF_DEFAULT_COMMAND "$1"
}

# use fd to generate the list for directory completion
_fzf_compgen_dir() {
    $FZF_DEFAULT_COMMAND --type directory "$1"
}

# use fd to generate the list for file completion
_fzf_compgen_file() {
    $FZF_DEFAULT_COMMAND --type file "$1"
}

# see /usr/share/fzf/completion.bash adapting from _fzf_path_completion
_fzf_file_completion() {
    __fzf_generic_path_completion _fzf_compgen_file "-m" "" "$@"
}

# programs to be completed by file always
file_cmds_always="kak ka shellcheck checkbashisms"

for cmd in $file_cmds_always; do
    __fzf_defc "$cmd" _fzf_file_completion "-o default -o bashdefault"
done

# fzf complete for kak
# _fzf_setup_completion path kak
# _fzf_setup_completion path ka

# programs to be completed by file when non root
file_cmds_non_root="dkak dka"
if [ ! "$LOGNAME" = "root" ] && [ "$(id -u)" -ne 0 ]; then
    for cmd in $file_cmds_non_root; do
        __fzf_defc "$cmd" _fzf_file_completion "-o default -o bashdefault"
    done
    # fzf complete for kak as root
    # _fzf_setup_completion path dka
fi

# alt+s search scripts
_fzf_script() {
    local bin_home="${XDG_BIN_HOME:-$HOME/.local/bin}"
    local min_depth
    if [ ! "$OS_TYPE" = "server" ]; then
        min_depth=2
    else
        min_depth=1
    fi
        # --height="${FZF_TMUX_HEIGHT:-40%}" \
        # --layout=default \
    script="$( \
        $FZF_DEFAULT_COMMAND \
        --type file --type symlink \
        --min-depth="$min_depth" \
        --base-directory="$bin_home" | \
        fzf \
    )"
    [ -z "$script" ] && return 1
    # shellcheck disable=SC2088
    path="~/.local/bin/$script"
    total_lenght="$(( ${#path} + ${#READLINE_LINE} ))"
    READLINE_LINE="${READLINE_LINE}${path}"
    READLINE_POINT="$total_lenght"
}
bind -m emacs-standard -x '"\es": _fzf_script'
bind -m vi-command -x '"\es": _fzf_script'
bind -m vi-insert -x '"\es": _fzf_script'

# alt+c search configs
_fzf_config() {
    local config_home="${XDG_CONFIG_HOME:-$HOME/.config}"
    local min_depth=1
        # --height="${FZF_TMUX_HEIGHT:-40%}" \
        # --layout=default \
    config="$( \
        $FZF_DEFAULT_COMMAND \
        --type file --type symlink \
        --min-depth="$min_depth" \
        --base-directory="$config_home" | \
        fzf \
    )"
    [ -z "$config" ] && return 1
    # shellcheck disable=SC2088
    path="~/.config/$config"
    total_lenght="$(( ${#path} + ${#READLINE_LINE} ))"
    READLINE_LINE="${READLINE_LINE}${path}"
    READLINE_POINT="$total_lenght"
}
bind -m emacs-standard -x '"\ec": _fzf_config'
bind -m vi-command -x '"\ec": _fzf_config'
bind -m vi-insert -x '"\ec": _fzf_config'

# see /usr/share/fzf/key-bindings.bash
# not really working with bash version > 4
# writes to prompt {directory}
# at least it is saved in bash history, with standard no
_fzf_cd_widget() {
    local directory
    directory="$(__fzf_cd__ | sed 's/^cd -- //')"
    total_lenght="$(( ${#directory} + ${#READLINE_LINE} ))"
    READLINE_LINE="${READLINE_LINE}${directory}"
    READLINE_POINT="$total_lenght"
}
# rebind to alt+d
bind -m emacs-standard -x '"\ed": _fzf_cd_widget'
bind -m vi-command -x '"\ed": _fzf_cd_widget'
bind -m vi-insert -x '"\ed": _fzf_cd_widget'

# https://github.com/junegunn/fzf/pull/2674
# https://unix.stackexchange.com/questions/573269/bash-is-there-a-way-to-invoke-bind-commands-e-g-redraw-current-line-programm
# _fzf_cd_widget() {
#     local cd_selected="$(__fzf_cd__)"
#     local selected="$(echo "$cd_selected" | sed 's/^.*cd //g')"
#     cd "$selected"
#     # eval "$cd_selected"
#     # pwd
#     # kill -WINCH "$$"
#     # killall bash
#     # echo "${PS1@P}"
#     # READLINE_LINE="${READLINE_LINE:0:$READLINE_POINT}$selected${READLINE_LINE:$READLINE_POINT}"
#     # READLINE_POINT=$(( READLINE_POINT + ${#selected} ))
# }

# remap fzf <a-c> to <c-f>

# unmap alt+c
# bind -m emacs-standard '"\ec":'
# bind -m vi-command '"\ec":'
# bind -m vi-insert '"\ec":'

# bind -m emacs-standard '"\er": redraw-current-line'
# bind -m vi-command '"\er": redraw-current-line'
# bind -m vi-insert '"\er": redraw-current-line'

# bind -m emacs-standard '"\C-f": " \C-b\C-k \C-u`__fzf_cd__`\e\C-e\er\C-m\C-y\C-h\e \C-y\ey\C-x\C-x\C-d"'
# bind -m vi-command '"\C-f": "\C-z\C-f\C-z"'
# bind -m vi-insert '"\C-f": "\C-z\C-f\C-z"'

# bind -m emacs-standard '"\C-f": " \C-k \C-u$(__fzf_cd__)\er\C-m \C-y\C-x\C-x"'
# bind -m vi-command '"\C-f": "\C-z\C-f\C-z"'
# bind -m vi-insert '"\C-f": "\C-z\C-f\C-z"'

# bind -m emacs-standard -x '"\C-f": $(__fzf_cd__)'
# bind -m vi-command -x '"\C-f": $(__fzf_cd__)'
# bind -m vi-insert -x '"\C-f": $(__fzf_cd__)'

# map control+f
# bind -m emacs-standard -x '"\C-f": _fzf_cd_widget'
# bind -m vi-command -x '"\C-f": _fzf_cd_widget'
# bind -m vi-insert -x '"\C-f": _fzf_cd_widget'
